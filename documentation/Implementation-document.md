# Implementation document

### Huffman coding
#### Compressing
The algorithm generates a code for each character (sequence of 8 bits). More common characters are given shorter codes. The codes are generated by constructing a Huffman tree.

Pseudocode for constructing the Huffman tree:
```
N = empty array of nodes
For each character:
    Create a node n for character
    n.weight = occurances of character in data
    n.char = character
    N.append(n)

While |N| > 1:
    Create a node n and add the two lightest nodes as its children
    n.weight = sum of the weights of the children.
    N.erase(children)
    N.append(n)
```

Example of constructing a Huffman tree:  
![Example image of constructing a Huffman tree][Huffman example]


The codes for the characters can be obtained recursively:
```
// The function is called with the remaining node and an empty code
function rec(cur_node, cur_code):
    if cur_node doesn't have children:
        codebook[cur_node.char] = cur_code
    else:
        rec(cur_node.children[0], cur_code + 0)
        rec(cur_node.children[1], cur_code + 1)
```

The codes are gathered into one codebook. The codebook has to be saved so that the decompressor can know what codes were used. To save the codebook more compactly it is converted to canonical Huffman.  
In the canonical Huffman the codes are changed:
1. Sort the codes first by code length and secondly by alphabetical value
2. Replace each code with a new one the following way:
   1. The first code is converted to only zeroes.
   2. Each subsequent code after that is assigned the next binary number in sequence.
   3. When reaching a longer code, then after incrementing append zeroes to the new code until the length of the new code is the same as the old code

Example:
We have codes:
```
A = 11
B = 0
C = 101
D = 100
```
After sorting:
```
B = 0
A = 11
C = 101
D = 100
```
After giving new codes
```
B = 0
A = 10
C = 110
D = 111
```

To save the codebook we only need to save the bit-lengths of the codes.
Example:
```
A = 10    (bits: 2)
B = 0     (bits: 1)
C = 110   (bits: 3)
D = 111   (bits: 3)
```
The following would be saved:
```
2, 1, 3, 3
```
In this program, all codes are saved for convenience, but that could be optimized.

After that, the algorithm replaces occurrences of the characters with their codes and saves the codebook and the compressed data to the output file.

#### Decompressing
Read the codebook and the encoded data from the input file.

Create a Huffman tree from the codes to more easily decode encoded data. Pseudocode to create the Huffman tree:
```
n = start node
for char, code in codebook:
    cur_node = n
    for bit in code:
        if bit == 0:
            if cur_node doesn't have a left child:
                cur_node.left = new node;
            cur_node = cur_node.left
        else:
            if cur_node doesn't have a right child:
                cur_node.right = new node;
            cur_node = cur_node.right
    cur_node.char = char
```

After that, we can decode the encoded data using the tree. Pseudocode to do this:

```
data = ""
cur_node = start node
for bit in encoded_data:
    if bit == 0:
        cur_node = cur_node.left
    else:
        cur_node = cur_node.right
    
    if cur_node has no children:
        data += cur_node.char
        cur_node = start node
```

After decoding the data it is written to the output file.

### Lempel–Ziv–Welch (LZW)
#### Compressing
A high level view of the encoding algorithm:
1. Initialize the dictionary to contain all strings of length one
3. Read bytes from the input into string S until S isn't in the dictionary
4. Go back one byte and remove the byte from S
6. Add the dictionary index for S to output
7. Add S followed by the next symbol in the input to the dictionary
8. Go to step 2

The amount of bits used for each code is one in the beginning and gets larger as codes require more bits.  
To do this, while the bit-length of the code is greater than code_bits, we write 111...111 to the file, where there are code_bits bits, where code_bits is the current code length in bits.

Pseudocode for writing the codes to the file:
```
code_bits = 1
for code in encoded_data:
    while code >= (1 << code_bits) - 1:
        file.write((1 << code_bits) - 1)
        ++code_bits
    file.write(code)
```

#### Decompressing
When reading the codes from the file, we need to be able to figure out where the number of bits used for the codes changes.
Pseudocode for reading the bits from the file:
```
codes = []
code_bits = 1
cur_byte = 0
bit_count = 0
for bit in compressed_data:
    cur_byte = (cur_byte << 1) | bit
    ++bit_count
    if bit_count == code_bits:
        if cur_byte >= (1 << code_bits) - 1:
            ++code_bits
        else:
            codes.append(cur_byte)
        cur_byte = 0
        bit_count = 0
```

A high level view of the decoding algorithm:
1. Initialize the dictionary to contain all strings of length one
2. Decode value and add decoded value to output
3. Add the first character of the next decoded string to the decoded value
4. Add the new string to the dictionary
5. Go to step 2

### Time and memory complexity
A = Alphabet size used in the Huffman coding
|                       | Time complexity | Memory complexity |
| --------------------- | --------------- | ----------------- |
| Huffman compression   | O(n+Alog(A))    | O(n+Alog(A))      |
| Huffman decompression | O(n+Alog(A))    | O(n+Alog(A))      |
| LZW compression       | O(n)            | O(n)              |
| LZW decompression     | O(n)            | O(n)              |

### Comparison
In the tests, the compression algorithms were tested with files containing random Finnish words separated with spaces.  
`./bnzip` uses Huffman coding and `./bnzip -l` uses LZW coding.  
![Graph comparing compression between different algorithms][Compression]
![Graph comparing compression ratios between different algorithms][Compression ratio]  
![Graph comparing compression times between different algorithms][Compression time]
![Graph comparing decompression times between different algorithms][Decompression time]

### Project structure
```
├── documentation
│   ├── definition-document.md
│   ├── images
│   │   ├── codecov-report.png
│   │   ├── compression.png
│   │   ├── compression-ratio.png
│   │   ├── compression-time.png
│   │   └── decompression-time.png
│   ├── Implementation-document.md
│   ├── testing-document.md
│   ├── usage-instructions.md
│   ├── week-report-1.md
│   ├── week-report-2.md
│   ├── week-report-3.md
│   ├── week-report-4.md
│   ├── week-report-5.md
│   └── week-report-6.md
├── Doxyfile
├── get-code-cov.sh
├── Makefile
├── README.md
├── src
│   ├── constants.hpp
│   ├── file-manager.cpp
│   ├── file-manager.hpp
│   ├── huffman
│   │   ├── huffman-coding.cpp
│   │   ├── huffman-coding.hpp
│   │   ├── huffman-runner.cpp
│   │   └── huffman-runner.hpp
│   ├── lzw
│   │   ├── lzw-coding.cpp
│   │   ├── lzw-coding.hpp
│   │   ├── lzw-runner.cpp
│   │   └── lzw-runner.hpp
│   ├── main.cpp
│   └── Makefile
└── tests
    ├── file-manager-test.cpp
    ├── helper.cpp
    ├── helper.hpp
    ├── huffman-test.cpp
    ├── lzw-test.cpp
    ├── Makefile
    └── test-files
        ├── all-bytes.bin
        ├── plaintext.txt
        ├── random-binary-data.bin
        ├── random-plaintext.txt
        └── special-characters.txt
```

### Possible improvements
* Progress indicator
* Deleting the original file

### Sources
* [Huffman coding (wikipedia.org)](https://en.wikipedia.org/wiki/Huffman_coding)
* [Canonical Huffman Code (wikipedia.org)](https://en.wikipedia.org/wiki/Canonical_Huffman_code)
* [Lempel-Ziv-Welch (wikipedia.org)](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)
* [Lempel-Ziv-Welch (geeksforgeeks.org)](https://www.geeksforgeeks.org/lzw-lempel-ziv-welch-compression-technique/)
* [List of words](https://kaino.kotus.fi/sanat/nykysuomi/)


#### Image sources
* [Example image of constructing a Huffman tree](https://en.wikipedia.org/wiki/File:HuffmanCodeAlg.png)

[Huffman example]: https://upload.wikimedia.org/wikipedia/commons/d/d8/HuffmanCodeAlg.png
[Compression]: ./images/compression.png
[Compression ratio]: ./images/compression-ratio.png
[Compression time]: ./images/compression-time.png
[Decompression time]: ./images/decompression-time.png