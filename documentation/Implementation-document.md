# Implementation document

### Huffman coding
#### Compressing
The algorithm generates a code for each character (sequence of 8 bits). More common characters are given shorter codes. The codes are generated by constructing a Huffman tree.

Pseudocode for constructing the Huffman tree:
```
N = empty array of nodes
For each character:
    Create a node n for character
    n.weight = occurances of character in data
    n.char = character
    N.append(n)

While |N| > 1:
    Create a node n and add the two lightest nodes as its children
    n.weight = sum of the weights of the children.
    N.erase(children)
    N.append(n)
```

Example of constructing a Huffman tree:  
![Example image of constructing a Huffman tree][Huffman example]


The codes for the characters can be obtained recursively:
```
// The function is called with the remaining node and an empty code
function rec(cur_node, cur_code):
    if cur_node doesn't have children:
        codebook[cur_node.char] = cur_code
    else:
        rec(cur_node.children[0], cur_code + 0)
        rec(cur_node.children[1], cur_code + 1)
```

The codes are gathered into one codebook. The codebook has to be saved so that the decompressor can know what codes were used. To save the codebook more compactly it is converted to canonical Huffman.  
In the canonical Huffman the codes are changed:
1. Sort the codes first by code length and secondly by alphabetical value
2. Replace each code with a new one the following way:
   1. The first code is converted to only zeroes.
   2. Each subsequent code after that is assigned the next binary number in sequence.
   3. When reaching a longer code, then after incrementing append zeroes to the new code until the length of the new code is the same as the old code

Example:
We have codes:
```
A = 11
B = 0
C = 101
D = 100
```
After sorting:
```
B = 0
A = 11
C = 101
D = 100
```
After giving new codes
```
B = 0
A = 10
C = 110
D = 111
```

To save the codebook we only need to save the bit-lengths of the codes.
Example:
```
A = 10    (bits: 2)
B = 0     (bits: 1)
C = 110   (bits: 3)
D = 111   (bits: 3)
```
The following would be saved:
```
2, 1, 3, 3
```
In this program, all codes are saved for convenience, but that could be optimized.

After that, the algorithm replaces occurrences of the characters with their codes and saves the codebook and the compressed data to the output file.

#### Decompressing
Read the codebook and the encoded data from the input file.

Create a Huffman tree from the codes to more easily decode encoded data. Pseudocode to create the Huffman tree:
```
n = start node
for char, code in codebook:
    cur_node = n
    for bit in code:
        if bit == 0:
            if cur_node doesn't have a left child:
                cur_node.left = new node;
            cur_node = cur_node.left
        else:
            if cur_node doesn't have a right child:
                cur_node.right = new node;
            cur_node = cur_node.right
    cur_node.char = char
```

After that, we can decode the encoded data using the tree. Pseudocode to do this:

```
data = ""
cur_node = start node
for bit in encoded_data:
    if bit == 0:
        cur_node = cur_node.left
    else:
        cur_node = cur_node.right
    
    if cur_node has no children:
        data += cur_node.char
        cur_node = start node
```

After decoding the data it is written to the output file.

### Lempel–Ziv–Welch (LZW)
#### Compressing
todo

#### Decompressing
todo

### Time and memory complexity
A = Alphabet size used in the Huffman coding
|                       | Time complexity | Memory complexity |
| --------------------- | --------------- | ----------------- |
| Huffman compression   | O(n+A²)         | O(n+A²)           |
| Huffman decompression | O(n+A²)         | O(n+A²)           |
| LZW compression       | O(n)            | O(n)              |
| LZW decompression     | O(n)            | O(n)              |

### Comparison
| file                                                             | original size | `./bnzip`     | `./bnzip -l` | `bzip2`      | `xz`         | `gzip`       |
| ---------------------------------------------------------------- | ------------- | ------------- | ------------ | ------------ | ------------ | ------------ |
| [Plain text](../tests/test-files/plaintext.txt)                  | 8000          | 2889 (36.1%)  | 556 (6.95%)  | 66 (0.83%)   | 120 (1.5%)   | 99 (1.24%)   |
| [Random plaintext](../tests/test-files/random-plaintext.txt)     | 12507         | 7008 (56.0%)  | 7847 (62.7%) | 5667 (45.3%) | 6240 (49.9%) | 6311 (50.5%) |
| [Special characters](../tests/test-files/special-characters.txt) | 13853         | 11754 (84.8%) | 3935 (28.4%) | 710 (5.13%)  | 412 (2.97%)  | 468 (3.38%)  |
| [All characters](../tests/test-files/all-characters.txt)         | 11520         | 9381 (81.4%)  | 6049 (52.5%) | 868 (7.53%)  | 396 (3.44%)  | 465 (4.04%)  |
| [Random binary data](../tests/test-files/random-binary-data.bin) | 10552         | 8532 (80.9%)  | 10365(98.2%) | 7555 (71.6%) | 7396 (70.1%) | 8607 (81.6%) |

### Project structure
```
├── documentation
│   ├── definition-document.md
│   ├── Implementation-document.md
│   ├── testing-document.md
│   ├── usage-instructions.md
│   ├── week-report-1.md
│   ├── week-report-2.md
│   ├── week-report-3.md
│   ├── week-report-4.md
│   ├── week-report-5.md
│   └── week-report-6.md
├── Doxyfile
├── get-code-cov.sh
├── Makefile
├── README.md
├── src
│   ├── constants.hpp
│   ├── file-manager.cpp
│   ├── file-manager.hpp
│   ├── huffman
│   │   ├── huffman-coding.cpp
│   │   ├── huffman-coding.hpp
│   │   ├── huffman-runner.cpp
│   │   └── huffman-runner.hpp
│   ├── lzw
│   │   ├── lzw-coding.cpp
│   │   ├── lzw-coding.hpp
│   │   ├── lzw-runner.cpp
│   │   └── lzw-runner.hpp
│   ├── main.cpp
│   └── Makefile
└── tests
    ├── file-manager-test.cpp
    ├── helper.cpp
    ├── helper.hpp
    ├── huffman-test.cpp
    ├── lzw-test.cpp
    ├── Makefile
    └── test-files
        ├── all-characters.txt
        ├── plaintext.txt
        ├── random-binary-data.bin
        ├── random-plaintext.txt
        └── special-characters.txt
```

### Possible improvements
* Variable-width codes in LZW coding
* Progress indicator

### Sources
* [Huffman coding (wikipedia.org)](https://en.wikipedia.org/wiki/Huffman_coding)
* [Canonical Huffman Code (wikipedia.org)](https://en.wikipedia.org/wiki/Canonical_Huffman_code)
* [Lempel-Ziv-Welch (wikipedia.org)](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch)
* [Lempel-Ziv-Welch (geeksforgeeks.org)](https://www.geeksforgeeks.org/lzw-lempel-ziv-welch-compression-technique/)


#### Image sources
* [Example image of constructing a Huffman tree](https://en.wikipedia.org/wiki/File:HuffmanCodeAlg.png)

[Huffman example]: https://upload.wikimedia.org/wikipedia/commons/d/d8/HuffmanCodeAlg.png