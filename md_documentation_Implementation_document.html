<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tiralabra: Implementation document</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tiralabra
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Implementation document </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2"></a>
Huffman coding</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
Compressing</h3>
<p >The algorithm generates a code for each character (sequence of 8 bits). More common characters are given shorter codes. The codes are generated by constructing a Huffman tree.</p>
<p >Pseudocode for constructing the Huffman tree: </p><div class="fragment"><div class="line">N = empty array of nodes</div>
<div class="line">For each character:</div>
<div class="line">    Create a node n for character</div>
<div class="line">    n.weight = occurances of character in data</div>
<div class="line">    n.char = character</div>
<div class="line">    N.append(n)</div>
<div class="line"> </div>
<div class="line">While |N| &gt; 1:</div>
<div class="line">    Create a node n and add the two lightest nodes as its children</div>
<div class="line">    n.weight = sum of the weights of the children.</div>
<div class="line">    N.erase(children)</div>
<div class="line">    N.append(n)</div>
</div><!-- fragment --><p >Example of constructing a Huffman tree: <br  />
 <img src="https://upload.wikimedia.org/wikipedia/commons/d/d8/HuffmanCodeAlg.png" alt="Example image of constructing a Huffman tree" class="inline"/></p>
<p >The codes for the characters can be obtained recursively: </p><div class="fragment"><div class="line">// The function is called with the remaining node and an empty code</div>
<div class="line">function rec(cur_node, cur_code):</div>
<div class="line">    if cur_node doesn&#39;t have children:</div>
<div class="line">        codebook[cur_node.char] = cur_code</div>
<div class="line">    else:</div>
<div class="line">        rec(cur_node.children[0], cur_code + 0)</div>
<div class="line">        rec(cur_node.children[1], cur_code + 1)</div>
</div><!-- fragment --><p >The codes are gathered into one codebook. The codebook has to be saved so that the decompressor can know what codes were used. To save the codebook more compactly it is converted to canonical Huffman. <br  />
 In the canonical Huffman the codes are changed:</p><ol type="1">
<li>Sort the codes first by code length and secondly by alphabetical value</li>
<li>Replace each code with a new one the following way:<ol type="a">
<li>The first code is converted to only zeroes.</li>
<li>Each subsequent code after that is assigned the next binary number in sequence.</li>
<li>When reaching a longer code, then after incrementing append zeroes to the new code until the length of the new code is the same as the old code</li>
</ol>
</li>
</ol>
<p >Example: We have codes: </p><div class="fragment"><div class="line">A = 11</div>
<div class="line">B = 0</div>
<div class="line">C = 101</div>
<div class="line">D = 100</div>
</div><!-- fragment --><p> After sorting: </p><div class="fragment"><div class="line">B = 0</div>
<div class="line">A = 11</div>
<div class="line">C = 101</div>
<div class="line">D = 100</div>
</div><!-- fragment --><p> After giving new codes </p><div class="fragment"><div class="line">B = 0</div>
<div class="line">A = 10</div>
<div class="line">C = 110</div>
<div class="line">D = 111</div>
</div><!-- fragment --><p >To save the codebook we only need to save the bit-lengths of the codes. Example: </p><div class="fragment"><div class="line">A = 10    (bits: 2)</div>
<div class="line">B = 0     (bits: 1)</div>
<div class="line">C = 110   (bits: 3)</div>
<div class="line">D = 111   (bits: 3)</div>
</div><!-- fragment --><p> The following would be saved: </p><div class="fragment"><div class="line">2, 1, 3, 3</div>
</div><!-- fragment --><p> In this program, all codes are saved for convenience, but that could be optimized.</p>
<p >After that, the algorithm replaces occurrences of the characters with their codes and saves the codebook and the compressed data to the output file.</p>
<h3><a class="anchor" id="autotoc_md4"></a>
Decompressing</h3>
<p >Read the codebook and the encoded data from the input file.</p>
<p >Create a Huffman tree from the codes to more easily decode encoded data. Pseudocode to create the Huffman tree: </p><div class="fragment"><div class="line">n = start node</div>
<div class="line">for char, code in codebook:</div>
<div class="line">    cur_node = n</div>
<div class="line">    for bit in code:</div>
<div class="line">        if bit == 0:</div>
<div class="line">            if cur_node doesn&#39;t have a left child:</div>
<div class="line">                cur_node.left = new node;</div>
<div class="line">            cur_node = cur_node.left</div>
<div class="line">        else:</div>
<div class="line">            if cur_node doesn&#39;t have a right child:</div>
<div class="line">                cur_node.right = new node;</div>
<div class="line">            cur_node = cur_node.right</div>
<div class="line">    cur_node.char = char</div>
</div><!-- fragment --><p >After that, we can decode the encoded data using the tree. Pseudocode to do this:</p>
<div class="fragment"><div class="line">data = &quot;&quot;</div>
<div class="line">cur_node = start node</div>
<div class="line">for bit in encoded_data:</div>
<div class="line">    if bit == 0:</div>
<div class="line">        cur_node = cur_node.left</div>
<div class="line">    else:</div>
<div class="line">        cur_node = cur_node.right</div>
<div class="line">    </div>
<div class="line">    if cur_node has no children:</div>
<div class="line">        data += cur_node.char</div>
<div class="line">        cur_node = start node</div>
</div><!-- fragment --><p >After decoding the data it is written to the output file.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Lempel–Ziv–Welch (LZW)</h2>
<h3><a class="anchor" id="autotoc_md6"></a>
Compressing</h3>
<p >A high level view of the encoding algorithm:</p><ol type="1">
<li>Initialize the dictionary to contain all strings of length one</li>
<li>Read bytes from the input into string S until S isn't in the dictionary</li>
<li>Go back one byte and remove the byte from S</li>
<li>Add the dictionary index for S to output</li>
<li>Add S followed by the next symbol in the input to the dictionary</li>
<li>Go to step 2</li>
</ol>
<p >The amount of bits used for each code is one in the beginning and gets larger as codes require more bits. <br  />
 To do this, while the bit-length of the code is greater than code_bits, we write 111...111 to the file, where there are code_bits bits, where code_bits is the current code length in bits.</p>
<p >Pseudocode for writing the codes to the file: </p><div class="fragment"><div class="line">code_bits = 1</div>
<div class="line">for code in encoded_data:</div>
<div class="line">    while code &gt;= (1 &lt;&lt; code_bits) - 1:</div>
<div class="line">        file.write((1 &lt;&lt; code_bits) - 1)</div>
<div class="line">        ++code_bits</div>
<div class="line">    file.write(code)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md7"></a>
Decompressing</h3>
<p >When reading the codes from the file, we need to be able to figure out where the number of bits used for the codes changes. Pseudocode for reading the bits from the file: </p><div class="fragment"><div class="line">codes = []</div>
<div class="line">code_bits = 1</div>
<div class="line">cur_byte = 0</div>
<div class="line">bit_count = 0</div>
<div class="line">for bit in compressed_data:</div>
<div class="line">    cur_byte = (cur_byte &lt;&lt; 1) | bit</div>
<div class="line">    ++bit_count</div>
<div class="line">    if bit_count == code_bits:</div>
<div class="line">        if cur_byte &gt;= (1 &lt;&lt; code_bits) - 1:</div>
<div class="line">            ++code_bits</div>
<div class="line">        else:</div>
<div class="line">            codes.append(cur_byte)</div>
<div class="line">        cur_byte = 0</div>
<div class="line">        bit_count = 0</div>
</div><!-- fragment --><p >A high level view of the decoding algorithm:</p><ol type="1">
<li>Initialize the dictionary to contain all strings of length one</li>
<li>Decode value and add decoded value to output</li>
<li>Add the first character of the next decoded string to the decoded value</li>
<li>Add the new string to the dictionary</li>
<li>Go to step 2</li>
</ol>
<h2><a class="anchor" id="autotoc_md8"></a>
Time and memory complexity</h2>
<p >A = Alphabet size used in the Huffman coding </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">Time complexity   </th><th class="markdownTableHeadNone">Memory complexity    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Huffman compression   </td><td class="markdownTableBodyNone">O(n+Alog(A))   </td><td class="markdownTableBodyNone">O(n+Alog(A))    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Huffman decompression   </td><td class="markdownTableBodyNone">O(n+Alog(A))   </td><td class="markdownTableBodyNone">O(n+Alog(A))    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">LZW compression   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">LZW decompression   </td><td class="markdownTableBodyNone">O(n)   </td><td class="markdownTableBodyNone">O(n)   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md9"></a>
Comparison</h2>
<p >In the tests, the compression algorithms were tested with files containing random Finnish words separated with spaces. <br  />
 <code>./bnzip</code> uses Huffman coding and <code>./bnzip -l</code> uses LZW coding. <br  />
 <img src="./images/compression.png" alt="Graph comparing compression between different algorithms" class="inline"/> <img src="./images/compression-ratio.png" alt="Graph comparing compression ratios between different algorithms" class="inline"/> <br  />
 <img src="./images/compression-time.png" alt="Graph comparing compression times between different algorithms" class="inline"/> <img src="./images/decompression-time.png" alt="Graph comparing decompression times between different algorithms" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md10"></a>
Project structure</h2>
<div class="fragment"><div class="line">├── documentation</div>
<div class="line">│   ├── definition-document.md</div>
<div class="line">│   ├── Implementation-document.md</div>
<div class="line">│   ├── testing-document.md</div>
<div class="line">│   ├── usage-instructions.md</div>
<div class="line">│   ├── week-report-1.md</div>
<div class="line">│   ├── week-report-2.md</div>
<div class="line">│   ├── week-report-3.md</div>
<div class="line">│   ├── week-report-4.md</div>
<div class="line">│   ├── week-report-5.md</div>
<div class="line">│   └── week-report-6.md</div>
<div class="line">├── Doxyfile</div>
<div class="line">├── get-code-cov.sh</div>
<div class="line">├── Makefile</div>
<div class="line">├── README.md</div>
<div class="line">├── src</div>
<div class="line">│   ├── constants.hpp</div>
<div class="line">│   ├── file-manager.cpp</div>
<div class="line">│   ├── file-manager.hpp</div>
<div class="line">│   ├── huffman</div>
<div class="line">│   │   ├── huffman-coding.cpp</div>
<div class="line">│   │   ├── huffman-coding.hpp</div>
<div class="line">│   │   ├── huffman-runner.cpp</div>
<div class="line">│   │   └── huffman-runner.hpp</div>
<div class="line">│   ├── lzw</div>
<div class="line">│   │   ├── lzw-coding.cpp</div>
<div class="line">│   │   ├── lzw-coding.hpp</div>
<div class="line">│   │   ├── lzw-runner.cpp</div>
<div class="line">│   │   └── lzw-runner.hpp</div>
<div class="line">│   ├── main.cpp</div>
<div class="line">│   └── Makefile</div>
<div class="line">└── tests</div>
<div class="line">    ├── file-manager-test.cpp</div>
<div class="line">    ├── helper.cpp</div>
<div class="line">    ├── helper.hpp</div>
<div class="line">    ├── huffman-test.cpp</div>
<div class="line">    ├── lzw-test.cpp</div>
<div class="line">    ├── Makefile</div>
<div class="line">    └── test-files</div>
<div class="line">        ├── all-characters.txt</div>
<div class="line">        ├── plaintext.txt</div>
<div class="line">        ├── random-binary-data.bin</div>
<div class="line">        ├── random-plaintext.txt</div>
<div class="line">        └── special-characters.txt</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Possible improvements</h2>
<ul>
<li>Progress indicator</li>
<li>Deleting the original file</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
Sources</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman coding (wikipedia.org)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Canonical_Huffman_code">Canonical Huffman Code (wikipedia.org)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch">Lempel-Ziv-Welch (wikipedia.org)</a></li>
<li><a href="https://www.geeksforgeeks.org/lzw-lempel-ziv-welch-compression-technique/">Lempel-Ziv-Welch (geeksforgeeks.org)</a></li>
<li><a href="https://kaino.kotus.fi/sanat/nykysuomi/">List of words</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md13"></a>
Image sources</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/File:HuffmanCodeAlg.png">Example image of constructing a Huffman tree</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
